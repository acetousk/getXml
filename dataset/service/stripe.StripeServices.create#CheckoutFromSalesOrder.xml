<!--Service Location stripe.StripeServices.create#CheckoutFromSalesOrder--><service verb="create" noun="CheckoutFromSalesOrder"><in-parameters><parameter name="paymentGatewayConfigId" required="true"/><parameter name="orderId" required="true"/><parameter name="orderPartSeqId"/><parameter name="customerPartyId" default="ec.user.userAccount?.partyId"/><parameter name="successUrl" required="true" default-value="${ec.web?.getWebappRootUrl(false,true)}"/><parameter name="cancelUrl" required="true" default-value="${ec.web?.getWebappRootUrl(false,true)}"/><parameter name="setup_future_usage" required="true" default-value="on_session"><description><![CDATA[Setup future usage for the PaymentIntent. One of on_session or off_session. Default is on_session. See: https://docs.stripe.com/api/checkout/sessions/create#create_checkout_session-payment_intent_data-setup_future_usage]]></description></parameter></in-parameters><out-parameters><parameter name="checkoutId"/><parameter name="checkoutUrl"/></out-parameters><actions><entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrderList" limit="2"><econdition field-name="orderId"/><econdition field-name="orderPartSeqId" ignore="!orderPartSeqId"/><econdition field-name="customerPartyId" ignore="!customerPartyId"/><order-by field-name="-entryDate"/></entity-find><if condition="!existingOrderList.getFirst()"><return error="true" type="danger" message="No order found for orderId ${orderId}."/></if><if condition="existingOrderList.size() >= 2"><return error="true" type="danger" message="Cannot have multiple order parts for the customer party (party is optional)"/></if><set field="orderHeaderAndPart" from="existingOrderList.getFirst()"/><if condition="!orderHeaderAndPart.vendorPartyId"><return error="true" type="danger" message="Must have an vendorPartyId that is has an OrgInternal PartyRole for orderPart ${orderHeaderAndPart.orderPartSeqId} on order ${orderHeaderAndPart.orderId}"/></if><entity-find-one entity-name="mantle.party.PartyRole" value-field="partyRole" auto-field-map="[                 partyId:orderHeaderAndPart.vendorPartyId,roleTypeId:'OrgInternal']"/><if condition="!partyRole"><return error="true" type="danger" message="Must have an vendorPartyId ${orderHeaderAndPart.vendorPartyId} that is has an OrgInternal PartyRole for orderPart ${orderHeaderAndPart.orderPartSeqId} on order ${orderHeaderAndPart.orderId}"/></if><set field="customer_creation" value="always"/><set field="customer" from="null"/><set field="customer_email" from="null"/><if condition="orderHeaderAndPart.customerPartyId"><entity-find entity-name="mantle.party.PartyIdentification" list="partyIdentificationList" limit="1"><econdition field-name="partyId" from="orderHeaderAndPart.customerPartyId"/><econdition field-name="partyIdTypeEnumId" value="PtidSci"/><econdition field-name="expireDate" operator="less-equals" from="ec.user.nowTimestamp" or-null="true"/></entity-find><if condition="partyIdentificationList.getFirst()?.idValue"><set field="customer_creation" value="if_required"/><set field="customer" from="partyIdentificationList.getFirst()?.idValue"/></if><if condition="!customer"><service-call name="mantle.party.ContactServices.get#PartyDefaultBilling" in-map="[partyId:orderHeaderAndPart.customerPartyId]" out-map="[postalContactMechId:context.postalContactMechId,telecomContactMechId:context.telecomContactMechId,emailContactMechId:context.emailContactMechId]"/><if condition="emailContactMechId"><entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="emailContactMech" auto-field-map="[contactMechId:emailContactMechId]"/><if condition="emailContactMech.infoString"><set field="customer_creation" value="if_required"/><set field="customer_email" from="emailContactMech.infoString"/></if></if></if></if><set field="stripeMap" from="[success_url:successUrl,cancel_url:cancelUrl,mode:'payment',line_items:[],                 payment_intent_data:[setup_future_usage:setup_future_usage],payment_method_data:[allow_redisplay:'always'],             ]"/><if condition="customer"><then><set field="stripeMap" from="stripeMap + [customer:customer]"/></then><else-if condition="customer_email"><set field="stripeMap" from="stripeMap + [customer_email:customer_email,customer_creation:customer_creation]"/></else-if></if><entity-find entity-name="mantle.order.OrderItem" list="orderItemList"><econdition field-name="orderId"/><econdition field-name="orderPartSeqId" ignore-if-empty="true"/><econdition field-name="orderItemSeqId" ignore-if-empty="true"/><econdition field-name="parentItemSeqId" operator="is-null"/><order-by field-name="orderPartSeqId,orderItemSeqId"/></entity-find><set field="topItemSeqIds" from="orderItemList*.orderItemSeqId"/><set field="currency" from="orderHeaderAndPart.currencyUomId?orderHeaderAndPart.currencyUomId.toLowerCase():'usd'"/><if condition="topItemSeqIds"><entity-find entity-name="mantle.order.OrderItem" list="childOrderItemList"><econdition field-name="orderId"/><econdition field-name="orderPartSeqId" ignore-if-empty="true"/><econdition field-name="orderItemSeqId" ignore-if-empty="true"/><econdition field-name="parentItemSeqId" operator="in" from="topItemSeqIds"/><order-by field-name="orderItemSeqId"/></entity-find><set field="orderPartIdDoneList" from="[]"/><script><![CDATA[// NOTE: must use orderItemList.size() on each iteration as EntityList size will change with child items added
                    for (int oiIdx = 0; oiIdx < orderItemList.size(); oiIdx++) {
                        context.orderItem = (Map) orderItemList.get(oiIdx)
                        String orderItemSeqId = orderItem.orderItemSeqId
                        List childList = childOrderItemList.findAll({ orderItemSeqId.equals(it.parentItemSeqId) })
                        Map<String, Object> orderItemTotalOut = ec.service.sync().name("mantle.order.OrderServices.get#OrderItemTotal")
                                .parameters([orderItem:orderItem, getChildrenTotals:false]).call()
                        stripeMap.line_items.addAll([quantity:(Integer)orderItemTotalOut.combinedQuantity,price_data:
                                [currency:currency,unit_amount_decimal:orderItemTotalOut.combinedAmount*100,product_data:
                                        [name:orderItem.itemDescription]]])
                        for (int cIdx = 0; cIdx < childList.size(); cIdx++) {
                            Map childItem = (Map) childList.get(cIdx)
                            oiIdx++
                            Map<String, Object> childItemTotalOut = ec.service.sync().name("mantle.order.OrderServices.get#OrderItemTotal")
                                    .parameters([orderItem:childItem, getChildrenTotals:false]).call()
                            stripeMap.line_items.addAll([quantity:(Integer)childItemTotalOut.combinedQuantity,price_data:
                                    [currency:currency,unit_amount_decimal:childItemTotalOut.combinedAmount*100,product_data:
                                            [name:childItem.itemDescription]]])
                        }
                    }]]></script></if><if condition="stripeMap.line_items.size() > 100"><return error="true" type="danger" message="Cannot have more than 100 line items. Please combine your line items."/></if><entity-find-one entity-name="mantle.account.method.PaymentGatewayConfig" value-field="paymentGateway" auto-field-map="[paymentGatewayConfigId:paymentGatewayConfigId]"/><if condition="!paymentGateway"><return error="true" type="danger" message="No PaymentGatewayConfig found for paymentGatewayConfigId ${paymentGatewayConfigId}"/></if><if condition="paymentGateway.systemMessageRemoteId"><entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="stripeRemote" auto-field-map="[systemMessageRemoteId:paymentGateway.systemMessageRemoteId]"/></if><if condition="!stripeRemote"><return error="true" type="danger" message="No SystemMessageRemote found for PaymentGatewayConfig ${paymentGatewayConfigId}"/></if><if condition="!stripeRemote.privateKey || !stripeRemote.publicKey || !stripeRemote.sharedSecret"><return error="true" type="danger" message="No ${!stripeRemote.privateKey?'private key':''} ${!stripeRemote.publicKey?'public key':''} ${!stripeRemote.sharedSecret?'shared secret':''} found for SystemMessageRemote ${stripeRemote.systemMessageRemoteId}. Go to ${ec.web.getWebappRootUrl(false,true)}/qapps/system/SystemMessage/Remote/MessageRemoteDetail?systemMessageRemoteId=${stripeRemote.systemMessageRemoteId} from https://dashboard.stripe.com/${'production'!=System.getProperty('instance_purpose') ? 'test/' : '' }apikeys"/></if><if condition="orderHeaderAndPart.checkoutId"><script><![CDATA[org.moqui.util.RestClient checkoutItemsRestClient = ec.service.rest().method(org.moqui.util.RestClient.GET)
                            .basicAuth(stripeRemote.privateKey,"")
                            .addBodyParameters([limit:stripeMap.line_items.size()+1 as String])
                    def checkoutItemsUriBuilder = checkoutItemsRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                            .path("/v1/checkout/sessions/${orderHeaderAndPart.checkoutId}/line_items")
                    checkoutItemsUriBuilder.build()

                    org.moqui.util.RestClient.RestResponse checkoutItemsRestResponse = checkoutItemsRestClient.call()
                    context.checkoutItemsResponseMap = (Map) checkoutItemsRestResponse.jsonObject()
                    if (checkoutItemsRestResponse.statusCode < 200 || checkoutItemsRestResponse.statusCode >= 300) {
                        ec.logger.warn("Could not create Checkout")
                        throw new org.moqui.BaseException("Got status code ${checkoutItemsRestResponse.statusCode} from Stripe on a create checkout session for the parameter '${checkoutItemsResponseMap.error.type}' and message '${checkoutItemsResponseMap.error.message}'")
                        return
                    }]]></script><set field="isTheSameOrder" from="stripeMap.line_items.collect { it.quantity * it.price_data.unit_amount_decimal }.sum() == checkoutItemsResponseMap.data.collect { (new BigDecimal(it.quantity)) * (new BigDecimal(it.price.unit_amount_decimal)) }.sum()"/><if condition="isTheSameOrder"><set field="isTheSameOrder" from="checkoutItemsResponseMap.data.price.every{ it.currency == currency }"/></if><if condition="isTheSameOrder"><then><log message="Found existing checkout session with the same order items, quantities, and prices"/><set field="checkoutId" from="orderHeaderAndPart.checkoutId"/><set field="checkoutUrl" from="orderHeaderAndPart.checkoutUrl"/><return/></then><else><log message="Cancelling checkout ${orderHeaderAndPart.checkoutId} because existing checkout session has different order items, quantities, or prices"/><service-call name="stripe.StripeServices.cancel#CheckoutFromSalesOrderPart" in-map="[orderId:orderId,orderPartSeqId:orderHeaderAndPart.orderPartSeqId]"/></else></if></if><set field="stripeMapTotal" from="stripeMap.line_items.collect { it.quantity * it.price_data.unit_amount_decimal }.sum()"/><set field="orderPartTotal" from="orderHeaderAndPart.partTotal*100"/><if condition="stripeMapTotal != orderPartTotal"><return error="true" type="danger" message="The sum of the external line items ${ec.l10n.formatCurrency((stripeMapTotal as BigDecimal), orderHeaderAndPart.currencyUomId?:'USD')} does not equal the order part total ${ec.l10n.formatCurrency((orderPartTotal as BigDecimal), orderHeaderAndPart.currencyUomId?:'USD')}."/></if><set field="stripeOutMap" from="flattenNestedMapWithKeys(stripeMap)"/><script><![CDATA[org.moqui.util.RestClient checkoutSessionRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .basicAuth(stripeRemote.privateKey,"")
                        .addBodyParameters(stripeOutMap)
                def checkoutSessionUriBuilder = checkoutSessionRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                        .path("/v1/checkout/sessions")
                checkoutSessionUriBuilder.build()

                org.moqui.util.RestClient.RestResponse checkoutSessionRestResponse = checkoutSessionRestClient.call()
                context.checkoutSessionResponseMap = (Map) checkoutSessionRestResponse.jsonObject()
                if (checkoutSessionRestResponse.statusCode < 200 || checkoutSessionRestResponse.statusCode >= 300) {
                    ec.logger.warn("Could not create Checkout")
                    throw new org.moqui.BaseException("Got status code ${checkoutSessionRestResponse.statusCode} from Stripe on a create checkout session for the parameter '${checkoutSessionResponseMap.error.type}' and message '${checkoutSessionResponseMap.error.message}'")
                    return
                }]]></script><set field="checkoutId" from="checkoutSessionResponseMap.id"/><set field="checkoutUrl" from="checkoutSessionResponseMap.url"/><entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" auto-field-map="[orderId:orderId,                 orderPartSeqId:orderHeaderAndPart.orderPartSeqId]" for-update="true"/><if condition="!orderPart"><return error="true" type="danger" message="Unable to save checkout information. No order part found for order ${orderId} order part ${orderHeaderAndPart.orderPartSeqId}."/></if><set field="orderPart.checkoutId" from="checkoutId"/><set field="orderPart.checkoutUrl" from="checkoutUrl"/><entity-update value-field="orderPart"/></actions></service>