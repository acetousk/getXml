<!--Service Location mantle.account.PaymentServices.refund#SinglePayment--><service verb="refund" noun="SinglePayment"><in-parameters><parameter name="paymentId" required="true"/><parameter name="refundPaymentId"><description><![CDATA[If specified use this existing refund Payment instead of creating a new one]]></description></parameter><parameter name="amount" type="BigDecimal"><description><![CDATA[Defaults to refund payment amount (if specified in refundPaymentId), or unapplied amount for Payment]]></description></parameter></in-parameters><out-parameters><parameter name="paymentGatewayResponseId"/><parameter name="refundPaymentId"/></out-parameters><actions><entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" for-update="true"/><if condition="payment == null"><return message="Payment ${paymentId} not found"/></if><if condition="refundPaymentId"><entity-find-one entity-name="mantle.account.payment.Payment" value-field="refundPayment" for-update="true"><field-map field-name="paymentId" from="refundPaymentId"/></entity-find-one><if condition="!(refundPayment.statusId in ['PmntPromised', 'PmntAuthorized'])"><return error="true" message="Cannot process refund payment ${paymentId} with status ${refundPayment.status?.description}, must be Promised or Authorized"/></if><if condition="refundPayment.fromPartyId != payment.toPartyId"><return error="true" message="From Party ${refundPayment.fromPartyId} on refund payment ${refundPaymentId} does not match To Party ${payment.toPartyId} on original payment ${paymentId}"/></if><if condition="refundPayment.toPartyId != payment.fromPartyId"><return error="true" message="To Party ${refundPayment.toPartyId} on refund payment ${refundPaymentId} does not match From Party ${payment.fromPartyId} on original payment ${paymentId}"/></if></if><if condition="!(payment.statusId in ['PmntDelivered', 'PmntConfirmed'])"><if condition="payment.statusId == 'PmntAuthorized'"><then><return error="true" message="Cannot refund payment ${paymentId}, because it is not delivered (captured). The payment is authorized, so try a release (void) instead of a refund."/></then><else><return error="true" message="Cannot refund payment ${paymentId}, must be delivered (captured) or confirmed paid"/></else></if></if><if condition="!amount"><if condition="refundPayment != null"><then><set field="amount" from="refundPayment.amount"/></then><else><service-call name="mantle.account.PaymentServices.get#PaymentTotals" in-map="[paymentId:paymentId]" out-map="[paymentTotal:totalOut.paymentTotal,appliedTotal:totalOut.appliedTotal,unappliedTotal:totalOut.unappliedTotal]"/><set field="amount" from="totalOut.unappliedTotal"/></else></if></if><if condition="amount == null || amount == 0.0"><return error="true" message="Refund amount cannot be zero"/></if><entity-find entity-name="mantle.account.payment.Payment" list="otherRefundPaymentList"><econdition field-name="refundForPaymentId" from="paymentId"/><econdition field-name="paymentId" operator="not-equals" from="refundPaymentId" ignore-if-empty="true"/><econdition field-name="statusId" operator="not-in" value="PmntCancelled,PmntVoid,PmntDeclined"/><select-field field-name="paymentId,amount"/></entity-find><set field="otherRefundTotal" from="otherRefundPaymentList ? otherRefundPaymentList*.amount.sum() : 0.0"/><set field="refundRemaining" from="payment.amount - otherRefundTotal"/><if condition="amount > refundRemaining"><return error="true" message="Refund amount ${amount} is greater than refundable amount ${refundRemaining} for payment ${paymentId} (original amount ${payment.amount}, other refunds ${otherRefundTotal})"/></if><service-call name="mantle.account.PaymentServices.get#AuthorizePaymentGatewayResponse" out-map="[paymentGatewayResponse:authRespOut.paymentGatewayResponse]" in-map="[paymentId:paymentId]"/><if condition="authRespOut.paymentGatewayResponse"><set field="paymentGatewayConfigId" from="authRespOut.paymentGatewayResponse.paymentGatewayConfigId"/></if><if condition="!paymentGatewayConfigId"><set field="paymentGatewayConfigId" from="payment.paymentGatewayConfigId"/></if><if condition="!paymentGatewayConfigId && payment.paymentMethodId"><set field="paymentMethod" from="payment.method"/><set field="paymentGatewayConfigId" from="paymentMethod?.paymentGatewayConfigId"/></if><if condition="!paymentGatewayConfigId && payment.paymentInstrumentEnumId == 'PiFinancialAccount'"><set field="paymentGatewayConfigId" from="FinancialAccountLocal"/></if><entity-find-one entity-name="mantle.account.method.PaymentGatewayConfig" value-field="paymentGatewayConfig" cache="true"/><if condition="paymentGatewayConfig == null"><return error="true" message="Not refunding Payment ${paymentId}, could not find PaymentGatewayConfig"/></if><if condition="!paymentGatewayConfig.refundServiceName"><log level="warn" message="Not refunding Payment ${paymentId}, no refundServiceName in PaymentGatewayConfig [${paymentGatewayConfigId}]"/><return/></if><if condition="!payment.paymentGatewayConfigId"><set field="payment.paymentGatewayConfigId" from="paymentGatewayConfigId"/><entity-update value-field="payment"/></if><service-call name="${paymentGatewayConfig.refundServiceName}" out-map="refundOut" in-map="[paymentId:payment.paymentId, amount:amount, paymentGatewayConfigId:paymentGatewayConfig.paymentGatewayConfigId]"/><set field="paymentGatewayResponseId" from="refundOut.paymentGatewayResponseId"/><if condition="!paymentGatewayResponseId"><then><log level="warn" message="Call to ${paymentGatewayConfig.refundServiceName} did not return a paymentGatewayResponseId (for Payment ${payment.paymentId})"/><entity-find entity-name="mantle.account.method.PaymentGatewayResponse" list="paymentGatewayResponseList"><econdition field-name="paymentMethodId" from="payment.paymentMethodId"/><order-by field-name="-transactionDate"/></entity-find><if condition="paymentGatewayResponseList && (paymentGatewayResponseList[0].transactionDate.time + 60000) > ec.user.nowTimestamp.time"><set field="paymentGatewayResponse" from="paymentGatewayResponseList[0]"/><set field="paymentGatewayResponseId" from="paymentGatewayResponse.paymentGatewayResponseId"/></if></then><else><entity-find-one entity-name="mantle.account.method.PaymentGatewayResponse" value-field="paymentGatewayResponse"><field-map field-name="paymentGatewayResponseId"/></entity-find-one></else></if><if condition="paymentGatewayResponse == null"><log level="error" message="No PaymentGatewayResponse found after call to ${paymentGatewayConfig.refundServiceName} (for Payment ${payment.paymentId})"/></if><if condition="paymentGatewayResponse?.resultSuccess == 'Y'"><if condition="refundPayment != null"><then><service-call name="update#mantle.account.payment.Payment" in-map="[paymentId:refundPayment.paymentId, statusId:'PmntDelivered', amount:amount,                                 paymentMethodId:payment.toPaymentMethodId, toPaymentMethodId:payment.paymentMethodId,                                 paymentInstrumentEnumId:payment.paymentInstrumentEnumId, refundForPaymentId:paymentId,                                 paymentGatewayConfigId:payment.paymentGatewayConfigId]"/><if condition="refundPayment.forInvoiceId"><service-call name="mantle.account.PaymentServices.apply#InvoicePayment" out-map="[paymentApplicationId:context.paymentApplicationId,amountApplied:context.amountApplied]" in-map="[paymentId:refundPayment.paymentId, invoiceId:refundPayment.forInvoiceId]"/></if></then><else><service-call name="mantle.account.PaymentServices.create#RefundPayment" out-map="[paymentId:refundOut.paymentId,paymentApplicationId:refundOut.paymentApplicationId,amount:refundOut.amount]" in-map="[                         paymentId:paymentId, amount:amount, statusId:'PmntDelivered', paymentMethodId:payment.toPaymentMethodId,                         toPaymentMethodId:payment.paymentMethodId, paymentInstrumentEnumId:payment.paymentInstrumentEnumId,                         paymentGatewayConfigId:payment.paymentGatewayConfigId]"/><set field="refundPaymentId" from="refundOut.paymentId"/></else></if></if></actions></service>