<!--Service Location mantle.party.TimeServices.create#TimePeriod--><service verb="create" noun="TimePeriod"><in-parameters><parameter name="parentPeriodId" type="java.lang.String" required="false" allow-html="none" entity-name="mantle.party.time.TimePeriod" field-name="parentPeriodId"/><parameter name="previousPeriodId" type="java.lang.String" required="false" allow-html="none" entity-name="mantle.party.time.TimePeriod" field-name="previousPeriodId"/><parameter name="timePeriodTypeId" type="java.lang.String" required="false" allow-html="none" entity-name="mantle.party.time.TimePeriod" field-name="timePeriodTypeId"/><parameter name="partyId" type="java.lang.String" required="false" allow-html="none" entity-name="mantle.party.time.TimePeriod" field-name="partyId"/><parameter name="periodNum" type="java.lang.Long" required="false" allow-html="none" entity-name="mantle.party.time.TimePeriod" field-name="periodNum"/><parameter name="periodName" type="java.lang.String" required="false" allow-html="none" entity-name="mantle.party.time.TimePeriod" field-name="periodName"/><parameter name="fromDate" type="java.sql.Date" required="false" allow-html="none" entity-name="mantle.party.time.TimePeriod" field-name="fromDate"/><parameter name="thruDate" type="java.sql.Date" required="false" allow-html="none" entity-name="mantle.party.time.TimePeriod" field-name="thruDate"/><parameter name="isClosed" type="java.lang.String" required="false" allow-html="none" entity-name="mantle.party.time.TimePeriod" field-name="isClosed" default-value="N"/><parameter name="lastUpdatedStamp" type="java.sql.Timestamp" required="false" allow-html="none" entity-name="mantle.party.time.TimePeriod" field-name="lastUpdatedStamp"/><parameter name="nextPeriodId"><description><![CDATA[If specified create the Previous period, before this one]]></description></parameter></in-parameters><out-parameters><parameter name="timePeriodId" entity-name="mantle.party.time.TimePeriod" field-name="timePeriodId"/></out-parameters><actions><entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="previousPeriod"><field-map field-name="timePeriodId" from="previousPeriodId"/></entity-find-one><entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="previousPeriodParent"><field-map field-name="timePeriodId" from="previousPeriod?.parentPeriodId"/></entity-find-one><entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="nextPeriod"><field-map field-name="timePeriodId" from="nextPeriodId"/></entity-find-one><entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="nextPeriodParent"><field-map field-name="timePeriodId" from="nextPeriod?.parentPeriodId"/></entity-find-one><if condition="previousPeriod != null"><then><if condition="!partyId"><set field="partyId" from="previousPeriod.partyId"/></if><if condition="!timePeriodTypeId"><set field="timePeriodTypeId" from="previousPeriod.timePeriodTypeId"/></if><if condition="fromDate == null"><script><![CDATA[def fromDateDt = java.time.ZonedDateTime.ofInstant(
                            java.time.Instant.ofEpochMilli((long) previousPeriod.thruDate.time), java.time.ZoneId.systemDefault())
                    fromDateDt = fromDateDt.plusDays(1)
                    fromDate = java.sql.Date.from(fromDateDt.toInstant())]]></script></if></then><else-if condition="nextPeriod != null"><if condition="nextPeriod.previousPeriodId"><set field="timePeriodId" from="nextPeriod.previousPeriodId"/><return/></if><if condition="!partyId"><set field="partyId" from="nextPeriod.partyId"/></if><if condition="!timePeriodTypeId"><set field="timePeriodTypeId" from="nextPeriod.timePeriodTypeId"/></if><if condition="thruDate == null"><script><![CDATA[def thruDateDt = java.time.ZonedDateTime.ofInstant(
                            java.time.Instant.ofEpochMilli((long) nextPeriod.fromDate.time), java.time.ZoneId.systemDefault())
                    thruDateDt = thruDateDt.minusDays(1)
                    thruDate = java.sql.Date.from(thruDateDt.toInstant())]]></script></if></else-if><else><if condition="!partyId"><message error="true"><![CDATA[With no previousPeriodId or nextPeriodId must specify partyId]]></message></if><if condition="!timePeriodTypeId"><message error="true"><![CDATA[With no previousPeriodId or nextPeriodId must specify timePeriodTypeId]]></message></if><if condition="!fromDate && !thruDate"><message error="true"><![CDATA[With no previousPeriodId or nextPeriodId must specify fromDate or thruDate]]></message></if><check-errors/></else></if><entity-find-one entity-name="mantle.party.time.TimePeriodType" value-field="timePeriodType" cache="true"/><if condition="fromDate == null"><then><script><![CDATA[java.time.temporal.TemporalUnit field = getTemporalUnitFromUomId(timePeriodType.lengthUomId)
                // use the database time zone, for Date fields this avoid moving across day boundaries
                def fromDateDt = java.time.ZonedDateTime.ofInstant(java.time.Instant.ofEpochMilli(thruDate.time), java.time.ZoneId.systemDefault())
                // step forward by one day so fromDate is the first day of this period, not the last day of the previous
                // NOTE: add one day before subtracting the time period instead of after; found case where
                //     subtracting 1 month went from the 30th of one month (Nov) to the 30th of the previous month (Oct)
                //     instead of the 31st, moving the day of month to the first for the fromDate of the following
                //     period first solves the problem
                fromDateDt = fromDateDt.plusDays(1)

                BigDecimal periodLength = timePeriodType.periodLength
                if (periodLength < 1 && timePeriodType.lengthUomId == 'TF_mon') {
                    // special case for Semi-Month
                    int maxDays = fromDateDt.range(java.time.temporal.ChronoField.DAY_OF_MONTH).getMaximum()
                    int days = (maxDays * periodLength).setScale(0, BigDecimal.ROUND_DOWN).intValue()
                    if (fromDateDt.dayOfMonth < days) fromDateDt = fromDateDt.minusDays(days)
                    else fromDateDt = fromDateDt.minusDays(maxDays - days)
                } else {
                    fromDateDt = fromDateDt.minus(periodLength.longValue(), field)
                }
                fromDate = java.sql.Date.from(fromDateDt.toInstant())]]></script></then><else><set field="fromDate" from="new java.sql.Date(fromDate.time)"/></else></if><entity-find entity-name="mantle.party.time.TimePeriod" list="existingPeriodList"><econdition field-name="partyId"/><econdition field-name="timePeriodTypeId"/><econdition field-name="fromDate"/></entity-find><if condition="existingPeriodList"><log level="warn" message="In create#TimePeriod existing ${timePeriodType.description} Time Period for Party [${partyId}] starting on ${fromDate}: ${existingPeriodList}"/><set field="timePeriodId" from="existingPeriodList[0].timePeriodId"/><return/></if><if condition="thruDate == null"><script><![CDATA[java.time.temporal.TemporalUnit field = getTemporalUnitFromUomId(timePeriodType.lengthUomId)
                // use the database time zone, for Date fields this avoid moving across day boundaries
                def thruDateDt = java.time.ZonedDateTime.ofInstant(java.time.Instant.ofEpochMilli(fromDate.time), java.time.ZoneId.systemDefault())

                BigDecimal periodLength = timePeriodType.periodLength
                if (periodLength < 1 && timePeriodType.lengthUomId == 'TF_mon') {
                    // special case for Semi-Month
                    int maxDays = thruDateDt.range(java.time.temporal.ChronoField.DAY_OF_MONTH).getMaximum()
                    int days = (maxDays * periodLength).setScale(0, BigDecimal.ROUND_DOWN).intValue()
                    if (thruDateDt.dayOfMonth < days) thruDateDt = thruDateDt.plusDays(days)
                    else thruDateDt = thruDateDt.plusDays(maxDays - days)
                } else {
                    thruDateDt = thruDateDt.plus(periodLength.longValue(), field)
                }
                // step back by one day so thruDate is the last day of this period, not the first day of the next
                thruDateDt = thruDateDt.minusDays(1)
                thruDate = java.sql.Date.from(thruDateDt.toInstant())]]></script></if><if condition="previousPeriod != null"><then><if condition="!parentPeriodId && previousPeriod.parentPeriodId"><if condition="previousPeriodParent.thruDate >= thruDate"><then><set field="parentPeriodId" from="previousPeriod.parentPeriodId"/></then><else><service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" in-map="[timePeriodId:previousPeriod.parentPeriodId]" out-map="[nextTimePeriodId:createNextParentOut.nextTimePeriodId,nextTimePeriod:createNextParentOut.nextTimePeriod]"/><set field="parentPeriodId" from="createNextParentOut.nextTimePeriodId"/></else></if></if></then><else-if condition="nextPeriod != null"><if condition="!parentPeriodId && nextPeriod.parentPeriodId"><if condition="nextPeriodParent.fromDate <= fromDate"><then><set field="parentPeriodId" from="nextPeriod.parentPeriodId"/></then><else><service-call name="mantle.party.TimeServices.getOrCreate#PreviousTimePeriod" in-map="[timePeriodId:nextPeriod.parentPeriodId]" out-map="[previousTimePeriodId:createPrevParentOut.previousTimePeriodId,previousTimePeriod:createPrevParentOut.previousTimePeriod]"/><set field="parentPeriodId" from="createPrevParentOut.previousTimePeriodId"/></else></if></if></else-if></if><if condition="!periodNum"><entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="parentPeriod"><field-map field-name="timePeriodId" from="parentPeriodId"/></entity-find-one><if condition="previousPeriod?.periodNum && parentPeriodId && previousPeriod?.parentPeriodId"><then><if condition="(parentPeriod.parentPeriodId ?: parentPeriodId) == (previousPeriodParent.parentPeriodId ?: previousPeriod.parentPeriodId)"><then><set field="periodNum" from="previousPeriod.periodNum + 1"/></then><else><set field="periodNum" from="1"/></else></if></then><else-if condition="nextPeriod?.periodNum && parentPeriodId && nextPeriod?.parentPeriodId && (parentPeriod.parentPeriodId ?: parentPeriodId) == (nextPeriodParent.parentPeriodId ?: nextPeriod.parentPeriodId)"><set field="periodNum" from="nextPeriod.periodNum - 1"/></else-if><else><set field="fromDateDt" from="java.time.ZonedDateTime.ofInstant(java.time.Instant.ofEpochMilli(fromDate.time), java.time.ZoneId.systemDefault())"/><if condition="timePeriodType.lengthUomId == 'TF_yr'"><then><set field="periodNum" from="fromDateDt.getYear()"/></then><else-if condition="timePeriodType.lengthUomId == 'TF_mon'"><set field="periodNum" from="((fromDateDt.getMonthValue() - 1) / timePeriodType.periodLength).intValue() + 1"/><if condition="timePeriodType.periodLength < 1 && fromDateDt.getDayOfMonth() > 1"><set field="periodNum" from="periodNum + 1"/></if></else-if><else-if condition="timePeriodType.lengthUomId == 'TF_wk'"><set field="periodNum" from="(fromDateDt.get(java.time.temporal.ChronoField.ALIGNED_WEEK_OF_YEAR) / timePeriodType.periodLength).intValue()"/></else-if></if></else></if></if><if condition="!periodName"><entity-find-one entity-name="mantle.party.PartyDetail" value-field="partyDetail"/><set field="fromLocalDate" from="java.time.LocalDate.parse(ec.l10n.format(fromDate, 'yyyy-MM-dd'))"/><set field="thruLocalDate" from="java.time.LocalDate.parse(ec.l10n.format(thruDate, 'yyyy-MM-dd'))"/><set field="periodName" from="ec.resource.expand('TimePeriodBaseNameTemplate', null)"/></if><script><![CDATA[try {
                    newTimePeriod = ec.entity.makeValue("mantle.party.time.TimePeriod")
                    newTimePeriod.setAll(context)
                    newTimePeriod.setSequencedIdPrimary()
                    newTimePeriod.create()
                    timePeriodId = newTimePeriod.get("timePeriodId")
                } catch (Exception e) {
                    // try once to find an existing and return its timePeriodId
                    existingTimePeriods = ec.entity.find("mantle.party.time.TimePeriod").condition("partyId", partyId)
                            .condition("timePeriodTypeId", timePeriodTypeId).condition("fromDate", fromDate).list()
                    if (existingTimePeriods) {
                        timePeriodId = existingTimePeriods[0].timePeriodId
                    } else {
                        throw e
                    }
                }]]></script><if condition="nextPeriod != null && timePeriodId"><set field="nextPeriod.previousPeriodId" from="timePeriodId"/><entity-update value-field="nextPeriod"/></if></actions></service>