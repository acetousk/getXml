<!--Service Location mantle.shipment.ShipmentServices.send#ShipmentStoreEmail--><service verb="send" noun="ShipmentStoreEmail"><in-parameters><parameter name="shipmentId" required="true"/><parameter name="emailTypeEnumId" required="true"/><parameter name="toAddresses"><text-email/></parameter><parameter name="forceByType" type="Boolean" default="false"/></in-parameters><out-parameters/><actions><entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList" distinct="true"><econdition field-name="shipmentId"/><select-field field-name="orderId,invoiceId"/></entity-find><set field="orderIdSet" from="new HashSet(shipmentItemSourceList*.orderId)"/><set field="invoiceIdSet" from="new HashSet(shipmentItemSourceList*.invoiceId)"/><script><![CDATA[orderIdSet.remove(null); invoiceIdSet.remove(null)]]></script><if condition="!orderIdSet"><return/></if><entity-find entity-name="mantle.order.OrderHeader" list="orderHeaderList"><econdition field-name="orderId" operator="in" from="orderIdSet"/></entity-find><set field="productStoreIdSet" from="new HashSet(orderHeaderList*.productStoreId)"/><script><![CDATA[productStoreIdSet.remove(null)]]></script><if condition="!productStoreIdSet"><return/></if><entity-find entity-name="mantle.product.store.ProductStoreEmail" list="storeEmailList"><date-filter/><econdition field-name="productStoreId" operator="in" from="productStoreIdSet"/><econdition field-name="emailTypeEnumId"/></entity-find><if condition="storeEmailList"><entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/><set field="toPartyId" from="shipment.toPartyId"/><if condition="!toAddresses"><service-call name="mantle.party.ContactServices.get#PartyContactInfo" out-map="[postalContactMechId:emailInfo.postalContactMechId,postalContactMech:emailInfo.postalContactMech,postalContactMechPurposeId:emailInfo.postalContactMechPurposeId,postalAddress:emailInfo.postalAddress,postalAddressStateGeo:emailInfo.postalAddressStateGeo,postalAddressCountryGeo:emailInfo.postalAddressCountryGeo,postalAddressGeoPoint:emailInfo.postalAddressGeoPoint,postalTrustLevelEnum:emailInfo.postalTrustLevelEnum,telecomContactMechId:emailInfo.telecomContactMechId,telecomContactMech:emailInfo.telecomContactMech,telecomPartyContactMech:emailInfo.telecomPartyContactMech,telecomContactMechPurposeId:emailInfo.telecomContactMechPurposeId,telecomNumber:emailInfo.telecomNumber,faxContactMechId:emailInfo.faxContactMechId,faxContactMech:emailInfo.faxContactMech,faxPartyContactMech:emailInfo.faxPartyContactMech,faxContactMechPurposeId:emailInfo.faxContactMechPurposeId,faxTelecomNumber:emailInfo.faxTelecomNumber,emailContactMechId:emailInfo.emailContactMechId,emailContactMech:emailInfo.emailContactMech,emailPartyContactMech:emailInfo.emailPartyContactMech,emailContactMechPurposeId:emailInfo.emailContactMechPurposeId,emailAddress:emailInfo.emailAddress,webContactMechId:emailInfo.webContactMechId,webContactMech:emailInfo.webContactMech,webPartyContactMech:emailInfo.webPartyContactMech,webContactMechPurposeId:emailInfo.webContactMechPurposeId,webAddress:emailInfo.webAddress,otherContactMechId:emailInfo.otherContactMechId,otherContactMech:emailInfo.otherContactMech,otherContactMechPurposeId:emailInfo.otherContactMechPurposeId,otherInfoString:emailInfo.otherInfoString]" in-map="[partyId:toPartyId, emailContactMechPurposeId:'EmailShippingDest', defaultToPrimaryPurpose:true]"/><set field="toAddresses" from="emailInfo.emailAddress"/><entity-find entity-name="moqui.security.UserAccount" list="userAccountList" limit="1"><econdition field-name="partyId" from="toPartyId"/></entity-find><if condition="userAccountList"><set field="toUserId" from="userAccountList[0].userId"/></if></if><if condition="!toAddresses"><return/></if><iterate list="storeEmailList" entry="storeEmail"><if condition="!storeEmail.emailTemplateId"><continue/></if><if condition="!forceByType"><entity-find entity-name="mantle.shipment.ShipmentEmailMessageDetail" list="existingMessages"><econdition field-name="shipmentId"/><econdition field-name="emailTypeEnumId"/><select-field field-name="emailMessageId"/></entity-find><if condition="existingMessages"><message type="warning"><![CDATA[Not sending ${emailTypeEnumId} email for shipment ${shipmentId}, found messages: ${existingMessages*.emailMessageId}]]></message><continue/></if></if><entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"><field-map field-name="productStoreId" from="storeEmail.productStoreId"/></entity-find-one><set field="bodyParameters" from="[shipmentId:shipmentId, orderIdSet:new TreeSet(orderIdSet),                         invoiceId:(invoiceIdSet ? invoiceIdSet.first() : null),                         storeDomain:productStore.storeDomain, profileUrlPath:productStore.profileUrlPath,                         headerImagePath:storeEmail.headerImagePath, detailLinkPath:storeEmail.detailLinkPath]"/><if condition="!storeEmail.emailTemplateId"><continue/></if><service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" out-map="[messageId:sendOut.messageId,emailMessageId:sendOut.emailMessageId]" out-map-add-to-existing="false" in-map="[emailTemplateId:storeEmail.emailTemplateId, emailTypeEnumId:emailTypeEnumId,                                 toAddresses:toAddresses, bodyParameters:bodyParameters, toUserId:toUserId]"/><script><![CDATA[if (sendOut.emailMessageId) { ec.service.sync().name("create#mantle.shipment.ShipmentEmailMessage")
                            .parameter("shipmentId", shipmentId).parameter("emailMessageId", sendOut.emailMessageId).disableAuthz().call() }]]></script><message><![CDATA[Email sent to ${toAddresses}${sendOut.emailMessageId ? ', message ID ' + sendOut.emailMessageId : ''}]]></message></iterate></if></actions></service>